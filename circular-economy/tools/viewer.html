<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Circular Economy Graph Viewer</title>
  <style>
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: system-ui, sans-serif;
      display: flex;
      flex-direction: column;
      height: 100vh;
    }
    header {
      padding: 0.5rem 1rem;
      border-bottom: 1px solid #ccc;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.9rem;
    }
    #container {
      display: flex;
      flex: 1;
      min-height: 0;
    }
    #cy {
      flex: 2;
      min-width: 0;
    }
    #details {
      flex: 1;
      border-left: 1px solid #ccc;
      padding: 0.5rem;
      overflow: auto;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 12px;
      background: #f8f8f8;
    }
    #details h2 {
      margin-top: 0;
    }
    #status {
      margin-left: auto;
      font-size: 0.8rem;
      color: #555;
    }
    label {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
    }
  </style>

  <!-- Cytoscape core -->
  <script src="https://unpkg.com/cytoscape/dist/cytoscape.min.js"></script>
</head>
<body>
  <header>
    <strong>Circular Economy Graph Viewer</strong>

    <label>
      JSON file:
      <input type="file" id="fileInput" accept=".json">
    </label>

    <label>
      <input type="checkbox" id="edgeLabelToggle">
      Show edge labels
    </label>

    <span id="status"></span>
  </header>

  <div id="container">
    <div id="cy"></div>
    <div id="details">
      <h2>Details</h2>
      <pre id="detailsContent">Load a JSON file generated by your ceml-json-generator and click on nodes or edges.</pre>
    </div>
  </div>

  <script>
    let cy = null;
    let currentGraph = null;
    let currentMetrics = null;
    let currentMetadata = null;
    let showEdgeLabels = false;

    function setStatus(text) {
      document.getElementById('status').textContent = text;
    }

    function showDetails(title, data) {
      const pre = document.getElementById('detailsContent');
      pre.textContent = title + '\n\n' + JSON.stringify(data, null, 2);
    }

    // --- JSON extraction ---

    function extractFromJson(json) {
      // Expect shape: { metadata, metrics, graph: { nodes, edges } }
      const metadata = json.metadata || null;
      const metrics = json.metrics || null;
      let graph = null;

      if (json.graph && Array.isArray(json.graph.nodes) && Array.isArray(json.graph.edges)) {
        graph = json.graph;
      } else if (Array.isArray(json.nodes) && Array.isArray(json.edges)) {
        // fallback: bare graph at root
        graph = { nodes: json.nodes, edges: json.edges };
      }

      return { metadata, metrics, graph };
    }

    // --- Graph conversion / styling ---

    function graphToElements(graph) {
      const elements = [];

      graph.nodes.forEach(node => {
        const attrs = node.attrs || {};
        const label =
          attrs.name ||
          attrs.productName ||
          attrs.componentName ||
          node.id;

        elements.push({
          data: {
            id: node.id,
            label,
            nodeType: node.type,
            attrs
          }
        });
      });

      graph.edges.forEach((edge, idx) => {
        elements.push({
          data: {
            id: edge.id || ('e' + idx),
            source: edge.source,
            target: edge.target,
            label: edge.type,
            edgeType: edge.type,
            attrs: edge.attrs || {}
          }
        });
      });

      return elements;
    }

    function applyEdgeLabelStyle() {
      if (!cy) return;
      cy.style()
        .selector('edge')
        .style('label', showEdgeLabels ? 'data(label)' : '')
        .update();
    }

    function runLayout() {
      if (!cy) return;
      cy.layout({
        name: 'cose',
        animate: false,
        fit: true,
        padding: 40,
        nodeRepulsion: 800000,
        idealEdgeLength: 120,
        edgeElasticity: 100,
        nestingFactor: 0.8,
        gravity: 80,
        numIter: 1000,
        nodeOverlap: 10
      }).run();
    }

    // --- Metrics mapping ---

    function getMetricsForNode(nodeData) {
      if (!currentMetrics) return null;
      const m = currentMetrics;
      const id = nodeData.id;
      const type = nodeData.nodeType;
      const attrs = nodeData.attrs || {};
      const result = {};

      if (type === 'FACILITY') {
        if (m.byFacility && m.byFacility[id]) {
          result.byFacility = m.byFacility[id];
        }
        if (m.goalComplianceByFacility && m.goalComplianceByFacility[id]) {
          result.goalComplianceByFacility = m.goalComplianceByFacility[id];
        }
      }

      if (type === 'RETAILER' && m.byRetailer && m.byRetailer[id]) {
        result.byRetailer = m.byRetailer[id];
      }

      if (type === 'CONSUMER' && m.byConsumer && m.byConsumer[id]) {
        result.byConsumer = m.byConsumer[id];
      }

      if (type === 'MANUFACTURER') {
        if (m.byManufacturer && m.byManufacturer[id]) {
          result.byManufacturer = m.byManufacturer[id];
        }
        const shipByDest = m.shipmentMetrics && m.shipmentMetrics.byDestinationManufacturer;
        if (shipByDest && shipByDest[id]) {
          result.shipmentRelated = shipByDest[id];
        }
      }

      if (type === 'PRODUCT') {
        const productName = attrs.productName;
        if (productName && m.byProductType && m.byProductType[productName]) {
          result.byProductType = m.byProductType[productName];
        }
      }

      if (Object.keys(result).length === 0) {
        return null;
      }
      return result;
    }

    function getGlobalSummary() {
      return {
        metadata: currentMetadata || null,
        metrics: currentMetrics || null
      };
    }

    // --- Rendering ---

    function renderGraph(graph) {
      currentGraph = graph;
      const elements = graphToElements(graph);

      if (!cy) {
        cy = cytoscape({
          container: document.getElementById('cy'),
          elements,
          style: [
            {
              selector: 'node',
              style: {
                'label': 'data(label)',
                'text-valign': 'center',
                'text-halign': 'center',
                'font-size': 9,
                'width': 30,
                'height': 30,
                'background-color': '#888',
                'color': '#000'
              }
            },
            {
              selector: 'edge',
              style: {
                'curve-style': 'unbundled-bezier',
                'control-point-step-size': 40,
                'target-arrow-shape': 'triangle',
                'target-arrow-color': '#bbb',
                'line-color': '#bbb',
                'width': 1,
                'font-size': 7,
                'text-rotation': 'autorotate',
                'label': ''
              }
            },
            { selector: 'node[nodeType = "PRODUCT"]',            style: { 'background-color': '#ffd54f' } },
            { selector: 'node[nodeType = "COMPONENT"]',          style: { 'background-color': '#4fc3f7' } },
            { selector: 'node[nodeType = "RETAILER"]',           style: { 'background-color': '#a5d6a7' } },
            { selector: 'node[nodeType = "MANUFACTURER"]',       style: { 'background-color': '#ce93d8' } },
            { selector: 'node[nodeType = "CONSUMER"]',           style: { 'background-color': '#ffab91' } },
            { selector: 'node[nodeType = "ORDER"]',              style: { 'background-color': '#b0bec5' } },
            { selector: 'node[nodeType = "RETURN"]',             style: { 'background-color': '#f48fb1' } },
            { selector: 'node[nodeType = "CIRCULAR_PROCESS"]',   style: { 'background-color': '#81d4fa' } },
            { selector: 'node[nodeType = "SHIPMENT"]',           style: { 'background-color': '#bcaaa4' } },
            { selector: 'node[nodeType = "FACILITY"]',           style: { 'background-color': '#c5e1a5' } },
            { selector: 'node[nodeType = "SUSTAINABILITY_GOAL"]',style: { 'background-color': '#ffe082' } }
          ],
          layout: { name: 'preset' }
        });

        cy.on('tap', 'node', evt => {
          const d = evt.target.data();
          const metrics = getMetricsForNode(d);
          const details = {
            id: d.id,
            type: d.nodeType,
            label: d.label,
            attrs: d.attrs
          };
          if (metrics) {
            details.metrics = metrics;
          }
          showDetails(`Node: ${d.id} (${d.nodeType})`, details);
        });

        cy.on('tap', 'edge', evt => {
          const d = evt.target.data();
          showDetails(
            `Edge: ${d.id} (${d.edgeType})`,
            {
              id: d.id,
              type: d.edgeType,
              source: d.source,
              target: d.target,
              attrs: d.attrs
            }
          );
        });

        cy.on('tap', e => {
          if (e.target === cy) {
            const summary = getGlobalSummary();
            showDetails('Global summary', summary);
          }
        });

      } else {
        cy.json({ elements });
      }

      applyEdgeLabelStyle();
      runLayout();

      const economyName = currentMetadata && currentMetadata.economyName
        ? currentMetadata.economyName
        : 'unknown';
      const metricsStatus = currentMetrics ? 'metrics loaded' : 'no metrics';
      setStatus(
        `Economy: ${economyName} â€“ nodes: ${graph.nodes.length}, edges: ${graph.edges.length} (${metricsStatus})`
      );
    }

    // --- File input handler ---

    document.getElementById('fileInput').addEventListener('change', event => {
      const file = event.target.files && event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = e => {
        try {
          const text = e.target.result;
          const json = JSON.parse(text);

          const { metadata, metrics, graph } = extractFromJson(json);

          if (!graph) {
            setStatus('Invalid JSON: could not find "graph" with nodes/edges');
            return;
          }

          currentMetadata = metadata;
          currentMetrics = metrics;
          renderGraph(graph);
        } catch (err) {
          console.error(err);
          setStatus('Error parsing JSON file');
        }
      };
      reader.readAsText(file);
    });

    document.getElementById('edgeLabelToggle').addEventListener('change', e => {
      showEdgeLabels = e.target.checked;
      applyEdgeLabelStyle();
    });
  </script>
</body>
</html>
